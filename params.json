{"name":"Odac","tagline":"Odac (Operations Dashboard for Apache CloudStack)","body":"# Odac (Operations Dashboard for Apache CloudStack)\r\n\r\n## What's Odac all about?\r\n\r\nI've been thinking about the Apache CloudStack UI's experience for operators, and although it's great in small environments, I believe that there could be significant improvement in the way that operators review and manage larger clouds. The layout of the native CloudStack UI is more focused on a graphical experience that helps explain the internal structure to the viewer. With a larger environment, the operator is (most likely) less interested in visually seeing relationships between the various infrastructure bits. What they want, is a dashboard view into their capacity (all available aspects), with drilldowns. They also need a much cleaner way to review the event stream that's generated by the system. To those ends, I started working on a project to create a prototype that might be one way to meet these needs. As with most of my postings these days, this is a fairly incomplete project at the moment so YMMV quite a bit.\r\n\r\n## Technical Summary\r\n\r\nThe project is broken up into three parts:\r\n* cs-operator-dash: contains the Rails UI\r\n* cs_eventconsumer: a gem that can run a daemon process to pull CloudStack events out of a RabbitMQ broker and push them into MongoDB\r\n* cs_capacityretriever: a gem that can run a daemon process to periodically pull various capacity information from a CloudStack management server via my cloudstack_ruby_client gem, again pushing that data into MongoDB\r\n\r\nObviously this requires a running CloudStack management server (configured with the RabbitMQ event handler). It also requires MongoDB to store the data from the 2 daemon processes.\r\n\r\nThe basic concept is that the cs-operator-dash Rails app is largely read-only, and works with data being populated into MongoDB via the two daemon processes. cs-operator-dash uses the Mongoid ORM to map the appropriate models to the collections being created by the back-end processes.\r\n\r\nOne of the main benefits to using a \"collector > datastore < UI\" architecture is that it allows the data to be stored as a historical record (that's how I get the trend lines).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}